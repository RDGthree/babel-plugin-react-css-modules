{"version":3,"sources":["../src/createSpreadMapper.ts"],"names":["createSpreadMapper","path","stats","result","attributeNames","optionsDefaults","opts","Object","assign","attributes","entries","filter","pair","attributeKeys","map","spreadAttributes","node","openingElement","attr","spread","attributeKey","destinationName","argument"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEA,MAAMA,kBAAkB,GAAG,CAACC,IAAD,EAAYC,KAAZ,KAAuD;AAChF,QAAMC,MAAM,GAAG,EAAf;AACA,MAAI;AACFC,IAAAA;AADE,MAEAC,wBAFJ;;AAIA,MAAIH,KAAK,CAACI,IAAN,IAAcJ,KAAK,CAACI,IAAN,CAAWF,cAA7B,EAA6C;AAC3CA,IAAAA,cAAc,GAAGG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,cAAlB,EAAkCF,KAAK,CAACI,IAAN,CAAWF,cAA7C,CAAjB;AACD;;AAED,QAAMK,UAAU,GAAGF,MAAM,CAACG,OAAP,CAAeN,cAAf,EAA+BO,MAA/B,CAAsCC,IAAI,IAAI;AAC/D,WAAOA,IAAI,CAAC,CAAD,CAAX;AACD,GAFkB,CAAnB;AAGA,QAAMC,aAAa,GAAGJ,UAAU,CAACK,GAAX,CAAeF,IAAI,IAAI;AAC3C,WAAOA,IAAI,CAAC,CAAD,CAAX;AACD,GAFqB,CAAtB;AAGA,QAAMG,gBAAgB,GAAGd,IAAI,CAACe,IAAL,CAAUC,cAAV,CAAyBR,UAAzB,CAAoCE,MAApC,CAA2CO,IAAI,IAAI;AAC1E,WAAO,iCAAqBA,IAArB,CAAP;AACD,GAFwB,CAAzB;;AAIA,OAAK,MAAMC,MAAX,IAAqBJ,gBAArB,EAAuC;AACrC,SAAK,MAAMK,YAAX,IAA2BP,aAA3B,EAA0C;AACxC,YAAMQ,eAAe,GAAGjB,cAAc,CAACgB,YAAD,CAAtC;;AAEA,UAAIjB,MAAM,CAACkB,eAAD,CAAV,EAA6B;AAC3BlB,QAAAA,MAAM,CAACkB,eAAD,CAAN,GAA0B,6BAAiB,GAAjB,EAAsBlB,MAAM,CAACkB,eAAD,CAA5B,EAA+C,kCAAsBF,MAAM,CAACG,QAA7B,EAAuC,6BAAiB,GAAjB,EAAsB,0BAAc,GAAd,CAAtB,EAA0C,8BAAkB,IAAlB,EAAwB,6BAAiBH,MAAM,CAACG,QAAxB,EAAkC,uBAAWD,eAAX,CAAlC,CAAxB,EAAwF,0BAAc,EAAd,CAAxF,CAA1C,CAAvC,EAA8L,0BAAc,EAAd,CAA9L,CAA/C,CAA1B;AACD,OAFD,MAEO;AACLlB,QAAAA,MAAM,CAACkB,eAAD,CAAN,GAA0B,kCAAsBF,MAAM,CAACG,QAA7B,EAAuC,8BAAkB,IAAlB,EAAwB,6BAAiBH,MAAM,CAACG,QAAxB,EAAkC,uBAAWD,eAAX,CAAlC,CAAxB,EAAwF,0BAAc,EAAd,CAAxF,CAAvC,EAAmJ,0BAAc,EAAd,CAAnJ,CAA1B;AACD;AACF;AACF;;AAED,SAAOlB,MAAP;AACD,CAjCD;;eAmCeH,kB","sourcesContent":["import { Expression, memberExpression, binaryExpression, conditionalExpression, stringLiteral, logicalExpression, identifier, isJSXSpreadAttribute } from \"@babel/types\";\nimport optionsDefaults from \"./schemas/optionsDefaults\";\n\nconst createSpreadMapper = (path: any, stats: any): Record<string, Expression> => {\n  const result = {};\n  let {\n    attributeNames\n  } = optionsDefaults;\n\n  if (stats.opts && stats.opts.attributeNames) {\n    attributeNames = Object.assign({}, attributeNames, stats.opts.attributeNames);\n  }\n\n  const attributes = Object.entries(attributeNames).filter(pair => {\n    return pair[1];\n  });\n  const attributeKeys = attributes.map(pair => {\n    return pair[0];\n  });\n  const spreadAttributes = path.node.openingElement.attributes.filter(attr => {\n    return isJSXSpreadAttribute(attr);\n  });\n\n  for (const spread of spreadAttributes) {\n    for (const attributeKey of attributeKeys) {\n      const destinationName = attributeNames[attributeKey];\n\n      if (result[destinationName]) {\n        result[destinationName] = binaryExpression('+', result[destinationName], conditionalExpression(spread.argument, binaryExpression('+', stringLiteral(' '), logicalExpression('||', memberExpression(spread.argument, identifier(destinationName)), stringLiteral(''))), stringLiteral('')));\n      } else {\n        result[destinationName] = conditionalExpression(spread.argument, logicalExpression('||', memberExpression(spread.argument, identifier(destinationName)), stringLiteral('')), stringLiteral(''));\n      }\n    }\n  }\n\n  return result;\n};\n\nexport default createSpreadMapper;\n"],"file":"createSpreadMapper.js"}
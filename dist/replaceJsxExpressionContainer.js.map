{"version":3,"sources":["../src/replaceJsxExpressionContainer.js"],"names":["t","path","styleNameAttribute","importedHelperIndentifier","styleModuleImportMapIdentifier","options","expressionContainerValue","value","classNameAttribute","node","openingElement","attributes","find","attribute","name","splice","indexOf","args","expression","handleMissingStyleName","optionsDefaults","push","styleNameExpression","callExpression","stringLiteral","Error"],"mappings":";;;;;;;AACA;;AAaA;;AACA;;AACA;;;;;;eAMe,CACbA,CADa,EAGbC,IAHa,EAIbC,kBAJa,EAKbC,yBALa,EAMbC,8BANa,EAObC,OAPa,KAQJ;AACT,QAAMC,wBAAwB,GAAGJ,kBAAkB,CAACK,KAApD;AACA,QAAMC,kBAAkB,GAAGP,IAAI,CAACQ,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CACxBC,IADwB,CAClBC,SAAD,IAAe;AACnB,WAAO,OAAOA,SAAS,CAACC,IAAjB,KAA0B,WAA1B,IAAyCD,SAAS,CAACC,IAAV,CAAeA,IAAf,KAAwB,WAAxE;AACD,GAHwB,CAA3B;;AAKA,MAAIN,kBAAJ,EAAwB;AACtBP,IAAAA,IAAI,CAACQ,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCI,MAApC,CAA2Cd,IAAI,CAACQ,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCK,OAApC,CAA4CR,kBAA5C,CAA3C,EAA4G,CAA5G;AACD;;AAEDP,EAAAA,IAAI,CAACQ,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCI,MAApC,CAA2Cd,IAAI,CAACQ,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCK,OAApC,CAA4Cd,kBAA5C,CAA3C,EAA4G,CAA5G;AAEA,QAAMe,IAAI,GAAG,CACXX,wBAAwB,CAACY,UADd,EAEXd,8BAFW,CAAb,CAbS,CAkBT;AACA;;AACA,MAAIC,OAAO,CAACc,sBAAR,KAAmCC,yBAAgBD,sBAAvD,EAA+E;AAC7EF,IAAAA,IAAI,CAACI,IAAL,CAAU,qCAAuBrB,CAAvB,EAA0BK,OAA1B,CAAV;AACD;;AAED,QAAMiB,mBAAmB,GAAGtB,CAAC,CAACuB,cAAF,CAC1BpB,yBAD0B,EAE1Bc,IAF0B,CAA5B;;AAKA,MAAIT,kBAAJ,EAAwB;AACtB,QAAI,4BAAgBA,kBAAkB,CAACD,KAAnC,CAAJ,EAA+C;AAC7CN,MAAAA,IAAI,CAACQ,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCU,IAApC,CAAyC,yBACvC,0BAAc,WAAd,CADuC,EAEvC,mCACE,6BACE,GADF,EAEErB,CAAC,CAACwB,aAAF,CAAgBhB,kBAAkB,CAACD,KAAnB,CAAyBA,KAAzB,GAAiC,GAAjD,CAFF,EAGEe,mBAHF,CADF,CAFuC,CAAzC;AAUD,KAXD,MAWO,IAAI,qCAAyBd,kBAAkB,CAACD,KAA5C,CAAJ,EAAwD;AAC7DN,MAAAA,IAAI,CAACQ,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCU,IAApC,CAAyC,yBACvC,0BAAc,WAAd,CADuC,EAEvC,mCACE,oCACEb,kBAAkB,CAACD,KAAnB,CAAyBW,UAD3B,EAEEI,mBAFF,CADF,CAFuC,CAAzC;AASD,KAVM,MAUA;AACL,YAAM,IAAIG,KAAJ,CAAU,6BAAV,CAAN;AACD;AACF,GAzBD,MAyBO;AACLxB,IAAAA,IAAI,CAACQ,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCU,IAApC,CAAyC,yBACvC,0BAAc,WAAd,CADuC,EAEvC,mCACEC,mBADF,CAFuC,CAAzC;AAMD;AACF,C","sourcesContent":["// @flow\nimport BabelTypes, {\n  binaryExpression,\n  Identifier,\n  isJSXExpressionContainer,\n  isStringLiteral,\n  jSXAttribute,\n  JSXAttribute,\n  jSXExpressionContainer,\n  jSXIdentifier\n} from '@babel/types';\nimport type {\n  HandleMissingStyleNameOptionType\n} from './types';\nimport conditionalClassMerge from './conditionalClassMerge';\nimport createObjectExpression from './createObjectExpression';\nimport optionsDefaults from './schemas/optionsDefaults';\n\ntype OptionsType = {|\n  handleMissingStyleName: HandleMissingStyleNameOptionType\n|};\n\nexport default (\n  t: BabelTypes,\n  // eslint-disable-next-line flowtype/no-weak-types\n  path: Object,\n  styleNameAttribute: JSXAttribute,\n  importedHelperIndentifier: Identifier,\n  styleModuleImportMapIdentifier: Identifier,\n  options: OptionsType\n): void => {\n  const expressionContainerValue = styleNameAttribute.value;\n  const classNameAttribute = path.node.openingElement.attributes\n    .find((attribute) => {\n      return typeof attribute.name !== 'undefined' && attribute.name.name === 'className';\n    });\n\n  if (classNameAttribute) {\n    path.node.openingElement.attributes.splice(path.node.openingElement.attributes.indexOf(classNameAttribute), 1);\n  }\n\n  path.node.openingElement.attributes.splice(path.node.openingElement.attributes.indexOf(styleNameAttribute), 1);\n\n  const args = [\n    expressionContainerValue.expression,\n    styleModuleImportMapIdentifier\n  ];\n\n  // Only provide options argument if the options are something other than default\n  // This helps save a few bits in the generated user code\n  if (options.handleMissingStyleName !== optionsDefaults.handleMissingStyleName) {\n    args.push(createObjectExpression(t, options));\n  }\n\n  const styleNameExpression = t.callExpression(\n    importedHelperIndentifier,\n    args\n  );\n\n  if (classNameAttribute) {\n    if (isStringLiteral(classNameAttribute.value)) {\n      path.node.openingElement.attributes.push(jSXAttribute(\n        jSXIdentifier('className'),\n        jSXExpressionContainer(\n          binaryExpression(\n            '+',\n            t.stringLiteral(classNameAttribute.value.value + ' '),\n            styleNameExpression\n          )\n        )\n      ));\n    } else if (isJSXExpressionContainer(classNameAttribute.value)) {\n      path.node.openingElement.attributes.push(jSXAttribute(\n        jSXIdentifier('className'),\n        jSXExpressionContainer(\n          conditionalClassMerge(\n            classNameAttribute.value.expression,\n            styleNameExpression\n          )\n        )\n      ));\n    } else {\n      throw new Error('Unexpected attribute value.');\n    }\n  } else {\n    path.node.openingElement.attributes.push(jSXAttribute(\n      jSXIdentifier('className'),\n      jSXExpressionContainer(\n        styleNameExpression\n      )\n    ));\n  }\n};\n"],"file":"replaceJsxExpressionContainer.js"}
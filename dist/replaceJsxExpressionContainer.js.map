{"version":3,"sources":["../src/replaceJsxExpressionContainer.ts"],"names":["t","path","sourceAttribute","destinationName","importedHelperIndentifier","styleModuleImportMapIdentifier","options","expressionContainerValue","value","destinationAttribute","node","openingElement","attributes","find","attribute","name","splice","indexOf","args","expression","handleMissingStyleName","optionsDefaults","autoResolveMultipleImports","push","styleNameExpression","callExpression","clone","stringLiteral","Error"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;;;eACgB,CAACA,CAAD,EAAIC,IAAJ,EAA+BC,eAA/B,EAA8DC,eAA9D,EAAuFC,yBAAvF,EAA8HC,8BAA9H,EAA0KC,OAA1K,KAAqN;AACnO,QAAMC,wBAAwB,GAAGL,eAAe,CAACM,KAAjD;AACA,QAAMC,oBAAoB,GAAGR,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCC,IAApC,CAAyCC,SAAS,IAAI;AACjF,WAAO,OAAOA,SAAS,CAACC,IAAjB,KAA0B,WAA1B,IAAyCD,SAAS,CAACC,IAAV,CAAeA,IAAf,KAAwBZ,eAAxE;AACD,GAF4B,CAA7B;;AAIA,MAAIM,oBAAJ,EAA0B;AACxBR,IAAAA,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCI,MAApC,CAA2Cf,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCK,OAApC,CAA4CR,oBAA5C,CAA3C,EAA8G,CAA9G;AACD;;AAEDR,EAAAA,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCI,MAApC,CAA2Cf,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCK,OAApC,CAA4Cf,eAA5C,CAA3C,EAAyG,CAAzG;AACA,QAAMgB,IAAI,GAAG,CAAEX,wBAAD,CAAkCY,UAAnC,EAA+Cd,8BAA/C,CAAb,CAXmO,CAanO;AACA;;AACA,MAAIC,OAAO,CAACc,sBAAR,KAAmCC,yBAAgBD,sBAAnD,IAA6Ed,OAAO,CAACgB,0BAAR,KAAuCD,yBAAgBC,0BAAxI,EAAoK;AAClKJ,IAAAA,IAAI,CAACK,IAAL,CAAU,qCAAuBvB,CAAvB,EAA0BM,OAA1B,CAAV;AACD;;AAED,QAAMkB,mBAAmB,GAAGxB,CAAC,CAACyB,cAAF,CAAiBzB,CAAC,CAAC0B,KAAF,CAAQtB,yBAAR,CAAjB,EAAqDc,IAArD,CAA5B;;AAEA,MAAIT,oBAAJ,EAA0B;AACxB,QAAI,4BAAgBA,oBAAoB,CAACD,KAArC,CAAJ,EAAiD;AAC/CP,MAAAA,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCW,IAApC,CAAyC,yBAAa,0BAAcpB,eAAd,CAAb,EAA6C,mCAAuB,6BAAiB,GAAjB,EAAsBH,CAAC,CAAC2B,aAAF,CAAgBlB,oBAAoB,CAACD,KAArB,CAA2BA,KAA3B,GAAmC,GAAnD,CAAtB,EAA+EgB,mBAA/E,CAAvB,CAA7C,CAAzC;AACD,KAFD,MAEO,IAAI,qCAAyBf,oBAAoB,CAACD,KAA9C,CAAJ,EAA0D;AAC/DP,MAAAA,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCW,IAApC,CAAyC,yBAAa,0BAAcpB,eAAd,CAAb,EAA6C,mCAAuB,oCAAsBM,oBAAoB,CAACD,KAArB,CAA2BW,UAAjD,EAA6DK,mBAA7D,CAAvB,CAA7C,CAAzC;AACD,KAFM,MAEA;AACL,YAAM,IAAII,KAAJ,CAAU,iCAAiCnB,oBAAoB,CAACD,KAAhE,CAAN;AACD;AACF,GARD,MAQO;AACLP,IAAAA,IAAI,CAACS,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCW,IAApC,CAAyC,yBAAa,0BAAcpB,eAAd,CAAb,EAA6C,mCAAuBqB,mBAAvB,CAA7C,CAAzC;AACD;AACF,C","sourcesContent":["import { binaryExpression, Identifier, isJSXExpressionContainer, isStringLiteral, jSXAttribute, JSXAttribute, jSXExpressionContainer, jSXIdentifier } from \"@babel/types\";\nimport type { GetClassNameOptionsType } from \"./types\";\nimport conditionalClassMerge from \"./conditionalClassMerge\";\nimport createObjectExpression from \"./createObjectExpression\";\nimport optionsDefaults from \"./schemas/optionsDefaults\";\nexport default ((t, path: Record<string, any>, sourceAttribute: JSXAttribute, destinationName: string, importedHelperIndentifier: Identifier, styleModuleImportMapIdentifier: Identifier, options: GetClassNameOptionsType): void => {\n  const expressionContainerValue = sourceAttribute.value;\n  const destinationAttribute = path.node.openingElement.attributes.find(attribute => {\n    return typeof attribute.name !== 'undefined' && attribute.name.name === destinationName;\n  });\n\n  if (destinationAttribute) {\n    path.node.openingElement.attributes.splice(path.node.openingElement.attributes.indexOf(destinationAttribute), 1);\n  }\n\n  path.node.openingElement.attributes.splice(path.node.openingElement.attributes.indexOf(sourceAttribute), 1);\n  const args = [(expressionContainerValue as any).expression, styleModuleImportMapIdentifier];\n\n  // Only provide options argument if the options are something other than default\n  // This helps save a few bits in the generated user code\n  if (options.handleMissingStyleName !== optionsDefaults.handleMissingStyleName || options.autoResolveMultipleImports !== optionsDefaults.autoResolveMultipleImports) {\n    args.push(createObjectExpression(t, options));\n  }\n\n  const styleNameExpression = t.callExpression(t.clone(importedHelperIndentifier), args);\n\n  if (destinationAttribute) {\n    if (isStringLiteral(destinationAttribute.value)) {\n      path.node.openingElement.attributes.push(jSXAttribute(jSXIdentifier(destinationName), jSXExpressionContainer(binaryExpression('+', t.stringLiteral(destinationAttribute.value.value + ' '), styleNameExpression))));\n    } else if (isJSXExpressionContainer(destinationAttribute.value)) {\n      path.node.openingElement.attributes.push(jSXAttribute(jSXIdentifier(destinationName), jSXExpressionContainer(conditionalClassMerge(destinationAttribute.value.expression, styleNameExpression))));\n    } else {\n      throw new Error('Unexpected attribute value: ' + destinationAttribute.value);\n    }\n  } else {\n    path.node.openingElement.attributes.push(jSXAttribute(jSXIdentifier(destinationName), jSXExpressionContainer(styleNameExpression)));\n  }\n});\n"],"file":"replaceJsxExpressionContainer.js"}